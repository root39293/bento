<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bento Chat Assistant</title>
    <style>
        .chat-container { margin: 20px; }
        .message { margin: 10px 0; }
        .user-message { color: blue; }
        .assistant-message { color: green; }
        .settings { margin-bottom: 20px; }
        .document-list {
            margin-top: 20px;
        }
        
        .document-item {
            display: flex;
            justify-content: space-between;
            align-items: start;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .document-info {
            flex: 1;
        }
        
        .document-date {
            color: #666;
            font-size: 0.9em;
            margin-left: 10px;
        }
        
        .document-preview {
            color: #444;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        .delete-btn {
            background-color: #ff4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .delete-btn:hover {
            background-color: #cc0000;
        }

        .document-status {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .document-status.processing {
            background-color: #fff3cd;
            color: #856404;
        }

        .document-status.completed {
            background-color: #d4edda;
            color: #155724;
        }

        .document-status.error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .document-metadata {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        .category-select {
            margin-right: 10px;
            padding: 4px;
        }

        .document-description {
            width: 300px;
            padding: 4px;
            margin-right: 10px;
        }

        .tags-container {
            margin-top: 10px;
        }

        .tag {
            background-color: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 5px;
            display: inline-flex;
            align-items: center;
        }

        .tag button {
            background: none;
            border: none;
            margin-left: 4px;
            cursor: pointer;
            color: #6c757d;
        }

        .tag-input {
            padding: 2px 4px;
            width: 100px;
        }

        .no-documents {
            text-align: center;
            padding: 20px;
            color: #666;
            background-color: #f8f9fa;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .no-documents.error {
            color: #721c24;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .chunks-container {
            margin-top: 10px;
            border-left: 2px solid #e9ecef;
            margin-left: 10px;
            padding-left: 10px;
        }
        
        .chunk-item {
            margin: 5px 0;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .chunk-header {
            color: #666;
            font-size: 0.8em;
            margin-bottom: 5px;
        }
        
        .toggle-chunks {
            background-color: #e9ecef;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        .toggle-chunks:hover {
            background-color: #dee2e6;
        }
        
        .chunks-hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="settings">
        <h3>API 키 설정</h3>
        <div>
            <label>OpenAI API Key:</label>
            <input type="password" id="openai-key">
            <button onclick="setApiKey('openai')">설정</button>
        </div>
        <div>
            <label>Anthropic API Key:</label>
            <input type="password" id="anthropic-key">
            <button onclick="setApiKey('anthropic')">설정</button>
        </div>
        <div>
            <label>모델 선택:</label>
            <select id="model-select">
                <option value="gpt-4o">GPT-4o</option>
                <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
            </select>
        </div>
        <div>
            <label>
                <input type="checkbox" id="context-enabled">
                컨텍스트 활성화
            </label>
            <label style="margin-left: 10px;">
                <input type="checkbox" id="rag-enabled">
                RAG 활성화
            </label>
        </div>
    </div>

    <div class="chat-container">
        <div id="chat-messages"></div>
        <div>
            <textarea id="user-input" rows="3" placeholder="메시지를 입력하세요..."></textarea>
            <button onclick="sendMessage()">전송</button>
            <button onclick="newChat()">새 대화</button>
            <button onclick="clearChat()">대화 지우기</button>
        </div>
    </div>

    <div class="document-management">
        <h3>문서 관리</h3>
        <div>
            <input type="file" id="document-upload" accept=".pdf,.docx,.txt" />
            <button onclick="uploadDocument()">문서 업로드</button>
        </div>
        
        <div class="document-list">
            <h4>업로드된 문서 목록</h4>
            <div id="document-list-container">
                <!-- 문서 목록이 여기에 동적으로 추가됨 -->
            </div>
        </div>
    </div>

    <script>
        let conversationId = Date.now().toString();

        async function setApiKey(type) {
            const key = document.getElementById(`${type}-key`).value;
            try {
                const response = await fetch('/api/v1/chat/set-api-key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ api_type: type, api_key: key })
                });
                const data = await response.json();
                alert(data.message);
            } catch (error) {
                alert('API 키 설정 중 오류가 발생했습니다.');
            }
        }

        async function sendMessage() {
            const input = document.getElementById('user-input');
            const message = input.value.trim();
            if (!message) return;

            // 사용자 메시지 표시
            appendMessage('user', message);
            input.value = '';

            const chatMessages = document.getElementById('chat-messages');
            const responseDiv = document.createElement('div');
            responseDiv.className = 'message assistant-message';
            chatMessages.appendChild(responseDiv);

            try {
                const response = await fetch('/api/v1/chat/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        question: message,
                        model: document.getElementById('model-select').value,
                        context_enabled: document.getElementById('context-enabled').checked,
                        rag_enabled: document.getElementById('rag-enabled').checked,
                        conversation_id: conversationId
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const {value, done} = await reader.read();
                    if (done) break;
                    const text = decoder.decode(value);
                    responseDiv.textContent += text;
                }
            } catch (error) {
                responseDiv.textContent = '오류가 발생했습니다: ' + error.message;
            }
        }

        function appendMessage(role, content) {
            const chatMessages = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}-message`;
            messageDiv.textContent = `${role === 'user' ? '사용자' : '어시스턴트'}: ${content}`;
            chatMessages.appendChild(messageDiv);
        }

        function newChat() {
            if (confirm('새로운 대화를 시작하시겠습니까?')) {
                document.getElementById('chat-messages').innerHTML = '';
                conversationId = Date.now().toString();
                appendMessage('system', '새로운 대화가 시작되었습니다.');
            }
        }

        function clearChat() {
            if (confirm('현재 대화 내용을 지우시겠습니까?')) {
                document.getElementById('chat-messages').innerHTML = '';
            }
        }

        document.getElementById('user-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        async function uploadDocument() {
            const fileInput = document.getElementById('document-upload');
            const file = fileInput.files[0];
            if (!file) {
                alert('파일을 선택해주세요.');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                console.log('파일 업로드 시도:', file.name);
                console.log('파일 타입:', file.type);
                
                // 타임아웃 설정을 늘린 fetch 요청
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30초 타임아웃
                
                const response = await fetch('/api/v1/documents/upload', {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log('응답 상태:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('응답 데이터:', data);
                alert(data.message);
                await loadDocuments(); // 업로드 성공 후 목록 새로고침
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.error('업로드 시간 초과');
                    alert('문서 업로드 시간이 초과되었습니다. 다시 시도해주세요.');
                } else {
                    console.error('업로드 오류:', error);
                    alert('문서 업로드 중 오류가 발생했습니다: ' + error.message);
                }
            }
        }

        async function loadDocuments() {
            try {
                // API 키가 설정되어 있는지 확인
                const openaiKey = document.getElementById('openai-key').value;
                if (!openaiKey) {
                    console.log('OpenAI API 키가 설정되지 않았습니다.');
                    const container = document.getElementById('document-list-container');
                    container.innerHTML = '<p class="no-documents">OpenAI API 키를 먼저 설정해주세요.</p>';
                    return;
                }

                const response = await fetch('/api/v1/documents/list');
                const documents = await response.json();
                
                const container = document.getElementById('document-list-container');
                
                if (!documents || documents.length === 0) {
                    container.innerHTML = '<p class="no-documents">업로드된 문서가 없습니다.</p>';
                    return;
                }
                
                container.innerHTML = '';
                documents.forEach(doc => {
                    const docElement = createDocumentElement(doc);
                    container.appendChild(docElement);
                });
            } catch (error) {
                console.error('문서 목록 로드 중 오류:', error);
                const container = document.getElementById('document-list-container');
                container.innerHTML = '<p class="no-documents error">문서 목록을 불러오는데 실패했습니다.</p>';
            }
        }

        function createDocumentElement(doc) {
            const docElement = document.createElement('div');
            docElement.className = 'document-item';
            docElement.setAttribute('data-doc-id', doc.id);  // 문서 ID를 요소에 저장
            
            const tags = doc.metadata.tags ? doc.metadata.tags.split(',').filter(tag => tag) : [];
            
            docElement.innerHTML = `
                <div class="document-info">
                    <div class="document-header">
                        <strong>${doc.metadata.source}</strong>
                        <span class="document-status ${doc.metadata.status}">${doc.metadata.status}</span>
                        <span class="document-date">${new Date(doc.metadata.timestamp).toLocaleString()}</span>
                    </div>
                    <div class="document-metadata">
                        <select class="category-select" onchange="updateCategory('${doc.id}', this.value)">
                            <option value="">카테고리 선택</option>
                            <option value="general" ${doc.metadata.category === 'general' ? 'selected' : ''}>일반</option>
                            <option value="technical" ${doc.metadata.category === 'technical' ? 'selected' : ''}>기술</option>
                            <option value="business" ${doc.metadata.category === 'business' ? 'selected' : ''}>비즈니스</option>
                        </select>
                        <input type="text" 
                               class="document-description" 
                               placeholder="문서 설명 입력..."
                               value="${doc.metadata.description || ''}"
                               onchange="updateDescription('${doc.id}', this.value)">
                        <div class="tags-container">
                            ${tags.map(tag => `
                                <span class="tag">${tag} <button onclick="removeTag('${doc.id}', '${tag}')">&times;</button></span>
                            `).join('')}
                            <input type="text" 
                                   class="tag-input" 
                                   placeholder="태그 추가..."
                                   onkeypress="addTag('${doc.id}', event)">
                        </div>
                    </div>
                    <button class="toggle-chunks" onclick="toggleChunks('${doc.id}')">
                        청크 보기 (${doc.chunks.length}개)
                    </button>
                    <div id="chunks-${doc.id}" class="chunks-container chunks-hidden">
                        ${doc.chunks.map((chunk, index) => `
                            <div class="chunk-item">
                                <div class="chunk-header">청크 ${index + 1}/${doc.chunks.length}</div>
                                <div class="chunk-content">${chunk.content}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="document-actions">
                    <button onclick="deleteDocument('${doc.id}')" class="delete-btn">삭제</button>
                </div>
            `;
            return docElement;
        }

        function toggleChunks(docId) {
            const chunksContainer = document.getElementById(`chunks-${docId}`);
            const button = chunksContainer.previousElementSibling;
            const isHidden = chunksContainer.classList.contains('chunks-hidden');
            
            chunksContainer.classList.toggle('chunks-hidden');
            button.textContent = isHidden ? '청크 숨기기' : `청크 보기 (${chunksContainer.children.length}개)`;
        }

        async function updateCategory(docId, category) {
            await updateDocumentMetadata(docId, { category });
        }

        async function updateDescription(docId, description) {
            await updateDocumentMetadata(docId, { description });
        }

        async function addTag(docId, event) {
            if (event.key === 'Enter') {
                const tag = event.target.value.trim();
                if (tag) {
                    const response = await fetch(`/api/v1/documents/${docId}`, {
                        method: 'GET'
                    });
                    const doc = await response.json();
                    const currentTags = doc.metadata.tags ? doc.metadata.tags.split(',').filter(t => t) : [];
                    const tags = [...new Set([...currentTags, tag])]; // 중복 제거
                    await updateDocumentMetadata(docId, { tags });
                    event.target.value = '';
                    await loadDocuments();
                }
            }
        }

        async function removeTag(docId, tagToRemove) {
            const response = await fetch(`/api/v1/documents/${docId}`, {
                method: 'GET'
            });
            const doc = await response.json();
            const currentTags = doc.metadata.tags ? doc.metadata.tags.split(',').filter(t => t) : [];
            const tags = currentTags.filter(tag => tag !== tagToRemove);
            await updateDocumentMetadata(docId, { tags });
            await loadDocuments();
        }

        async function updateDocumentMetadata(docId, updates) {
            try {
                const response = await fetch(`/api/v1/documents/${docId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });
                
                if (!response.ok) {
                    throw new Error('메타데이터 업데이트 실패');
                }
                
                await loadDocuments();
            } catch (error) {
                console.error('메타데이터 업데이트 중 오류:', error);
                alert('메타데이터 업데이트에 실패했습니다.');
            }
        }

        async function deleteDocument(documentId) {
            if (!confirm('이 문서를 삭제하시겠습니까?')) return;
            
            try {
                const response = await fetch(`/api/v1/documents/${documentId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    // 성공적으로 삭제되면 해당 문서 요소를 UI에서 즉시 제거
                    const docElement = document.querySelector(`[data-doc-id="${documentId}"]`);
                    if (docElement) {
                        docElement.remove();
                    }
                    
                    // 문서 목록 새로고침
                    await loadDocuments();
                    alert('문서가 삭제되었습니다.');
                } else {
                    const error = await response.json();
                    throw new Error(error.detail);
                }
            } catch (error) {
                console.error('문서 삭제 중 오류:', error);
                alert('문서 삭제에 실패했습니다.');
            }
        }

        // 페이지 로드 시 문서 목록 로드
        document.addEventListener('DOMContentLoaded', loadDocuments);
    </script>
</body>
</html> 